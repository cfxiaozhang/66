clc;
clear;

%% 参数设置
numCustomers = 50; % 客户数量
maxIter = 50; % 最大迭代次数
numAnts = 100; % 蚂蚁数量
alpha = 1; % 信息素启发式因子
beta = 5; % 期望启发式因子
rho = 0.8; % 信息素挥发因子
Q = 100; % 信息素增强系数

% 成本系数
F = 500; % 每辆车的固定成本
C = 2; % 每公里运输成本
penalty_coeff = randi([5, 15], numCustomers, 1); % 每个客户时间窗罚系数
mu = 1; % 每单位时间的货损成本
G = 0.5; % 温湿度设备成本系数

% 客户位置和需求等随机生成
depot = [0, 0]; % 配送中心坐标
customerPos = randi([0, 100], numCustomers, 2); % 随机生成客户坐标
timeWindows = sort(randi([1, 100], numCustomers, 2), 2); % 时间窗 [start, end]
demand = randi([1, 10], numCustomers, 1); % 每个客户的需求
vehicleCapacity = 50; % 车辆最大载重

% 距离与时间矩阵
nodes = [depot; customerPos]; % 所有节点坐标
distMatrix = squareform(pdist(nodes)); % 节点间距离矩阵
travelTime = distMatrix / 30; % 平均速度假设为30单位/小时

% 使用最近邻算法获得初始解
numNodes = numCustomers + 1;
bestRoute = nearestNeighborInit(numNodes, distMatrix);
bestTotalCost = inf;

%% 蚁群算法迭代
pheromone = ones(numNodes); % 信息素矩阵
costHistory = zeros(maxIter, 1);

for iter = 1:maxIter
    routes = cell(numAnts, 1);
    totalCosts = zeros(numAnts, 1);
    
    for k = 1:numAnts
        route = [1]; % 从配送中心出发
        load = 0; % 当前载重
        time = 0; % 当前时间
        totalCost = F; % 初始总成本包含固定成本
        
        while length(route) < numCustomers + 1
            currentNode = route(end);
            unvisited = setdiff(2:numNodes, route); % 未访问节点
            
            if isempty(unvisited)
                route = [route, 1];
                break;
            end
            
            % 转移概率计算
            prob = zeros(size(unvisited));
            for j = 1:length(unvisited)
                nextNode = unvisited(j);
                tau = pheromone(currentNode, nextNode)^alpha; % 信息素
                eta = (1 / distMatrix(currentNode, nextNode))^beta; % 启发式信息
                prob(j) = tau * eta;
            end
            prob = prob / sum(prob);
            
            % 轮盘赌选择下一节点
            nextNode = unvisited(rouletteWheelSelection(prob));
            
            % 判断是否满足时间窗约束和载重约束
            travelTime_ij = travelTime(currentNode, nextNode);
            arrivalTime = time + travelTime_ij; % 到达下一个节点的时间
            timeViolation = max(0, arrivalTime - timeWindows(nextNode - 1, 2));
            
            if load + demand(nextNode - 1) <= vehicleCapacity
                route = [route, nextNode];
                load = load + demand(nextNode - 1);
                time = max(arrivalTime, timeWindows(nextNode - 1, 1)); % 更新时间
                
                % 累计运输成本
                totalCost = totalCost + C * distMatrix(currentNode, nextNode);
                totalCost = totalCost + penalty_coeff(nextNode - 1) * timeViolation;
                totalCost = totalCost + demand(nextNode - 1) * mu * travelTime_ij;
                totalCost = totalCost + G * travelTime_ij;
            else
                route = [route, 1]; % 返回配送中心
                load = 0;
                time = 0;
            end
        end
        
        routes{k} = route;
        totalCosts(k) = totalCost;
    end
    
    % 更新全局最优解
    [minTotalCost, minIndex] = min(totalCosts);
    if minTotalCost < bestTotalCost
        bestTotalCost = minTotalCost;
        bestRoute = routes{minIndex};
    end
    
    % 两两交换法优化路径
    bestRoute = twoOpt(bestRoute, distMatrix);
    
    % 记录历史最优解
    costHistory(iter) = bestTotalCost;
    fprintf('迭代 %d: 最优总成本 = %.2f\n', iter, bestTotalCost);
    
    % 信息素更新
    pheromone = (1 - rho) * pheromone;
    for k = 1:numAnts
        route = routes{k};
        for j = 1:length(route) - 1
            pheromone(route(j), route(j + 1)) = pheromone(route(j), route(j + 1)) + Q / totalCosts(k);
        end
    end
end

%% 结果绘图
figure(1);
plot(1:maxIter, costHistory, '-', 'LineWidth', 1.5);
title('收敛曲线');
xlabel('迭代次数');
ylabel('总成本');
grid on;

figure(2);
plot(nodes(:, 1), nodes(:, 2), 'bo');
hold on;
plot(nodes(1, 1), nodes(1, 2), 'ks', 'MarkerSize', 10, 'MarkerFaceColor', 'k'); % 配送中心
for i = 2:numCustomers + 1
    text(nodes(i, 1), nodes(i, 2), [' ', num2str(i - 1)]);
end
for i = 1:length(bestRoute) - 1
    plot([nodes(bestRoute(i), 1), nodes(bestRoute(i + 1), 1)], ...
         [nodes(bestRoute(i), 2), nodes(bestRoute(i + 1), 2)], 'r-');
end
title('最优路径');
xlabel('X坐标');
ylabel('Y坐标');
grid on;